# ASA 預測專案 - 問題與解決方案紀錄

## 資料清洗階段

### 問題 1: WEIGHT 欄位存在 0 值和空值
**發現時機**: 逐欄位資料品質檢查
**檢查方式**: `train_df['WEIGHT'].describe()` 和 `train_df['WEIGHT'].isna().sum()`
**問題描述**:
- 507 筆 WEIGHT = 0
- 727 筆 WEIGHT 為空值
- 總計約 1,234 筆有問題

**問題原因**: 資料輸入錯誤或未記錄
**解決方案**:
```python
# 步驟 1: 將 0 轉為 NaN
train_df.loc[train_df['WEIGHT'] == 0, 'WEIGHT'] = np.nan

# 步驟 2: 用性別+年齡組中位數填補
train_df['WEIGHT'] = train_df.groupby(['Gender', 'age_group'])['WEIGHT'].transform(
    lambda x: x.fillna(x.median())
)
```
**效果**: 所有 WEIGHT 欄位都有有效值
**驗證**: `train_df['WEIGHT'].isna().sum()` → 0

---

### 問題 2: HEIGHT 缺失率高達 26.4%
**發現時機**: 逐欄位資料品質檢查
**檢查方式**: `train_df['HEIGHT'].isna().sum() / len(train_df)`
**問題描述**: 3,893 筆 HEIGHT 缺失，會嚴重影響 BMI 計算

**分析過程**:
1. 交叉比對 Patient_Source：
   ```python
   train_df.groupby('Patient_Source')['HEIGHT'].apply(lambda x: x.isna().mean())
   ```
   → 門診來源缺失率更高

2. 交叉比對 ICU_Patient：
   ```python
   train_df.groupby('ICU_Patient')['HEIGHT'].apply(lambda x: x.isna().mean())
   ```
   → 非 ICU 缺失率更高

3. 交叉比對 ASA_Rating：
   ```python
   train_df.groupby('ASA_Rating')['HEIGHT'].apply(lambda x: x.isna().mean())
   ```
   → ASA 1-2 缺失率更高

4. 進一步驗證：交叉比對手術類型和用藥，確認缺失者慢性病相關用藥較少

**問題原因**: **MNAR (Missing Not At Random)**
- 門診/低風險患者術前評估較簡化
- 缺失主要發生在低風險患者，對預測高風險患者影響較小

**解決方案**: 用性別+年齡組中位數填補
```python
train_df['HEIGHT'] = train_df.groupby(['Gender', 'age_group'])['HEIGHT'].transform(
    lambda x: x.fillna(x.median()))
```

---

### 問題 3: HEIGHT = 88.9cm 異常值
**發現時機**: 統計摘要檢查
**檢查方式**: `train_df['HEIGHT'].describe()` 看 min 值
**問題描述**: 3 筆資料 HEIGHT = 88.9cm

**問題原因**: 成人身高不可能低於 100cm，判定為資料輸入錯誤
**解決方案**:
```python
# 先將異常值轉為 NaN
train_df.loc[train_df['HEIGHT'] < 100, 'HEIGHT'] = np.nan
# 然後用中位數填補（與問題2一起處理）
```

---

### 問題 4: BMI 欄位不存在
**發現時機**: 文獻回顧後
**檢查方式**: `'BMI' in train_df.columns` → False
**問題描述**: 原始資料沒有 BMI 欄位

**問題原因**: 原始資料只有 HEIGHT 和 WEIGHT，需自行計算
**重要性**: 文獻指出 BMI 是 ASA 分級的明確標準
- BMI < 30: ASA I
- BMI 30-35: ASA II
- BMI ≥ 40: ASA III

**解決方案**: 在 HEIGHT/WEIGHT 清洗完成後計算
```python
train_df['BMI'] = train_df['WEIGHT'] / ((train_df['HEIGHT'] / 100) ** 2)
```
**驗證**: 檢查 BMI 範圍是否合理 (約 15-60)

---

### 問題 5: Anesthesia_Method 有重複類別
**發現時機**: 類別欄位檢查
**檢查方式**: `train_df['Anesthesia_Method'].unique()`
**問題描述**: 'MAC' 和 'MAC ' 被視為不同類別（尾部有空格）

**問題原因**: 資料輸入時不小心多打空格
**解決方案**:
```python
train_df['Anesthesia_Method'] = train_df['Anesthesia_Method'].str.strip()
```
**補充**: 另有 11 筆缺失值，在模型訓練時填為 'Unknown'

---

### 問題 6: Surgery_Count = 0
**發現時機**: 邏輯檢查
**檢查方式**: `(train_df['Surgery_Count'] == 0).sum()`
**問題描述**: 部分 Surgery_Count = 0

**問題原因**: 邏輯錯誤，既然有手術記錄，至少要有 1 次手術
**解決方案**:
```python
train_df.loc[train_df['Surgery_Count'] == 0, 'Surgery_Count'] = 1
```

---

### 問題 7: properties_display 欄位格式問題
**發現時機**: 逐欄位資料品質檢查
**檢查方式**: 抽樣查看內容
**問題描述**:
- 連續空格
- 缺失值標記不統一
- 欄位名稱格式不一致

**問題原因**: 原始資料格式不統一，可能來自護理記錄系統
**解決方案**:
```python
# 移除多餘空格
train_df['properties_display'] = train_df['properties_display'].str.replace(r'\s+', ' ', regex=True)
# 統一缺失值
train_df['properties_display'] = train_df['properties_display'].replace(['', 'N/A', 'None'], np.nan)
```
**結論**: 經分析此欄位與 ASA 相關性較低，暫不深入提取特徵

---

### 問題 8: Catheter_Use 欄位格式問題
**發現時機**: 逐欄位資料品質檢查
**檢查方式**: `train_df['Catheter_Use'].unique()`
**問題描述**:
- 連續空格
- 類似名稱未合併 (INTRA-OSSEOUS vs INTRAOSSEOUS)

**問題原因**: 資料輸入格式不統一
**解決方案**:
```python
# 移除多餘空格
train_df['Catheter_Use'] = train_df['Catheter_Use'].str.replace(r'\s+', ' ', regex=True)
# 統一名稱
train_df['Catheter_Use'] = train_df['Catheter_Use'].str.replace('INTRA-OSSEOUS', 'INTRAOSSEOUS')
```

---

### 問題 9: ASA_Rating 類別不平衡
**發現時機**: 目標變數分析
**檢查方式**: `train_df['ASA_Rating'].value_counts(normalize=True)`
**問題描述**:
- ASA 1: 5.4%
- ASA 2: 34.2%
- ASA 3: 51.2%
- ASA 4: 9.2%
- 比例 ASA 3 : ASA 1 = 9.4 : 1

**問題原因**: 真實醫療場景中，中等風險患者較多，極端風險較少
**解決方案**:
1. 模型訓練時使用 `class_weight='balanced'`
2. 或使用 SMOTE 過採樣（方法F）

---

## 模型訓練階段

### 問題 10: XGBoost 標籤格式錯誤
**發現時機**: 模型訓練時報錯
**錯誤訊息**:
```
ValueError: Invalid classes inferred from unique values of `y`.
Expected: [0 1 2 3], got [1 2 3 4]
```
**原因**: XGBoost 要求標籤從 0 開始
**解決方案**:
```python
# 訓練前
y_train = y_train - 1  # 1-4 → 0-3

# 預測後
test_predictions_original = test_predictions + 1  # 0-3 → 1-4
```

---

### 問題 11: Kaggle Submission 格式錯誤
**發現時機**: 提交時被拒絕
**問題描述**: 欄位名稱不符合要求格式
**解決方案**:
```python
# 錯誤
submission = pd.DataFrame({
    'Index': range(len(test_predictions)),  # ❌
    'ASA_Rating': test_predictions_original
})

# 正確
submission = pd.DataFrame({
    'Id': range(len(test_predictions)),  # ✅
    'ASA_Rating': test_predictions_original
})
```

---

### 問題 12: 檔案編碼問題
**發現時機**: Excel 開啟 CSV 時
**問題描述**: 中文欄位顯示亂碼
**解決方案**:
```python
# 讀取時指定編碼
df = pd.read_csv('file.csv', encoding='latin-1')
# 或
df = pd.read_csv('file.csv', encoding='utf-8-sig')
```

---

## 模型優化階段

### 問題 13: 本地分數與 Kaggle 分數不一致
**發現時機**: 比較各方法的本地 F1 和 Kaggle Score
**現象**:
| 方法 | 本地 F1 | Kaggle Score |
|------|---------|--------------|
| B | 0.5122 | 0.52588 |
| C | 0.4974 | 0.53120 |

方法C本地較差，但Kaggle較好
**分析**:
- 本地驗證集 (20%) 與 Kaggle 測試集分布可能不同
- 交互特徵在測試集上泛化更好
**學習**: 不能完全依賴本地驗證分數做決策

---

### 問題 14: 模型融合效果不如預期
**發現時機**: 方法D結果
**現象**: 融合 (0.52592) ≈ 方法B (0.52588)，沒有提升
**分析**:
- 最佳本地權重 B:0.7, C:0.3
- 但方法C在Kaggle上更好，這個權重反而稀釋了C的貢獻
**學習**: 融合權重應該根據實際測試集表現調整，而非只看本地驗證

---

### 問題 15: SMOTE 效果不佳
**發現時機**: 方法F結果
**現象**:
- 本地 F1: 0.4974 → 0.4859 (-2.3%)
- **Kaggle: 0.53120 → 0.51602 (-2.9%)**
**分析**:
- SMOTE 產生過多合成樣本導致模型過擬合
- 合成樣本可能不符合真實資料分布
- 破壞了原始類別間的邊界特性
**結論**: 在此資料集上，SMOTE 無效，`class_weight='balanced'` 是更好的選擇

---

## 環境問題

### 問題 16: Python 模組未安裝
**錯誤訊息**: `ModuleNotFoundError: No module named 'optuna'`
**解決方案**:
```bash
pip3 install optuna
pip3 install imbalanced-learn  # for SMOTE
```

### 問題 17: Python 命令找不到
**錯誤訊息**: `command not found: python`
**解決方案**: macOS 使用 `python3` 而非 `python`

---

## 總結：常見錯誤類型

1. **資料品質問題**: 缺失值、異常值、格式不一致
2. **標籤格式問題**: 0-based vs 1-based
3. **檔案格式問題**: 編碼、欄位名稱
4. **驗證策略問題**: 本地 vs 測試集分布差異
5. **環境問題**: 套件安裝、Python 版本

---

*文件建立日期: 2026-01-19*
